"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[358],{5479:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var i=s(31085),n=s(71184);const o={custom_edit_url:"https://github.com/facebook/lexical/tree/main/packages/lexical-history/README.md"},r="@lexical/history",c={id:"packages/lexical-history",title:"@lexical/history",description:"See API Documentation",source:"@site/docs/packages/lexical-history.md",sourceDirName:"packages",slug:"/packages/lexical-history",permalink:"/docs/packages/lexical-history",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/lexical/tree/main/packages/lexical-history/README.md",tags:[],version:"current",frontMatter:{custom_edit_url:"https://github.com/facebook/lexical/tree/main/packages/lexical-history/README.md"},sidebar:"docs",previous:{title:"@lexical/headless",permalink:"/docs/packages/lexical-headless"},next:{title:"@lexical/html",permalink:"/docs/packages/lexical-html"}},a={},l=[{value:"Methods",id:"methods",level:3},{value:"<code>registerHistory</code>",id:"registerhistory",level:4},{value:"Commands",id:"commands",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",img:"img",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"lexicalhistory",children:(0,i.jsx)(t.code,{children:"@lexical/history"})})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://lexical.dev/docs/api/modules/lexical_history",children:(0,i.jsx)(t.img,{src:"https://lexical.dev/img/see-api-documentation.svg",alt:"See API Documentation"})})}),"\n",(0,i.jsx)(t.p,{children:"This package contains history helpers for Lexical."}),"\n",(0,i.jsx)(t.h3,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(t.h4,{id:"registerhistory",children:(0,i.jsx)(t.code,{children:"registerHistory"})}),"\n",(0,i.jsxs)(t.p,{children:["Registers necessary listeners to manage undo/redo history stack and related editor commands. It returns ",(0,i.jsx)(t.code,{children:"unregister"})," callback that cleans up all listeners and should be called on editor unmount."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"function registerHistory(\r\n  editor: LexicalEditor,\r\n  externalHistoryState: HistoryState,\r\n  delay: number,\r\n): () => void\n"})}),"\n",(0,i.jsx)(t.h3,{id:"commands",children:"Commands"}),"\n",(0,i.jsxs)(t.p,{children:["History package handles ",(0,i.jsx)(t.code,{children:"UNDO_COMMAND"}),", ",(0,i.jsx)(t.code,{children:"REDO_COMMAND"})," and ",(0,i.jsx)(t.code,{children:"CLEAR_HISTORY_COMMAND"})," commands. It also triggers ",(0,i.jsx)(t.code,{children:"CAN_UNDO_COMMAND"})," and ",(0,i.jsx)(t.code,{children:"CAN_REDO_COMMAND"})," commands when history state is changed. These commands could be used to work with history state:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-jsx",children:"import {UNDO_COMMAND, REDO_COMMAND} from 'lexical';\r\n\r\n<Toolbar>\r\n  <Button onClick={() => editor.dispatchCommand(UNDO_COMMAND)}>Undo</Button>\r\n  <Button onClick={() => editor.dispatchCommand(REDO_COMMAND)}>Redo</Button>\r\n</Toolbar>;\n"})})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},71184:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>c});var i=s(14041);const n={},o=i.createContext(n);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);