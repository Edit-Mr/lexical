"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[8576],{72552:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>a});var i=t(31085),r=t(71184);const o={sidebar_position:15},s="Creating a Plugin",d={id:"getting-started/creating-plugin",title:"Creating a Plugin",description:"This page covers Lexical plugin creation, independently of any framework or library. For those not yet familiar with Lexical it's advisable to check out the Quick Start (Vanilla JS) page.",source:"@site/docs/getting-started/creating-plugin.md",sourceDirName:"getting-started",slug:"/getting-started/creating-plugin",permalink:"/docs/getting-started/creating-plugin",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/lexical/tree/main/packages/lexical-website/docs/getting-started/creating-plugin.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{sidebar_position:15},sidebar:"docs",previous:{title:"Supported Browsers",permalink:"/docs/getting-started/supported-browsers"},next:{title:"Developer Tools",permalink:"/docs/getting-started/devtools"}},c={},a=[{value:"Preconditions",id:"preconditions",level:2},{value:"Creating own <code>LexicalNode</code>",id:"creating-own-lexicalnode",level:2},{value:"Creating Node Transform",id:"creating-node-transform",level:2},{value:"Putting it all together",id:"putting-it-all-together",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"creating-a-plugin",children:"Creating a Plugin"})}),"\n",(0,i.jsxs)(n.p,{children:["This page covers Lexical plugin creation, independently of any framework or library. For those not yet familiar with Lexical it's advisable to ",(0,i.jsx)(n.a,{href:"/docs/getting-started/quick-start",children:"check out the Quick Start (Vanilla JS) page"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Lexical, on the contrary to many other frameworks, doesn't define any specific interface for its plugins. The plugin in its simplest form is a function that accepts a ",(0,i.jsx)(n.code,{children:"LexicalEditor"})," instance, and returns a cleanup function. With access to the ",(0,i.jsx)(n.code,{children:"LexicalEditor"}),", plugin can extend editor via ",(0,i.jsx)(n.a,{href:"/docs/concepts/commands",children:"Commands"}),", ",(0,i.jsx)(n.a,{href:"/docs/concepts/transforms",children:"Transforms"}),", ",(0,i.jsx)(n.a,{href:"/docs/concepts/nodes",children:"Nodes"}),", or other APIs."]}),"\n",(0,i.jsxs)(n.p,{children:["In this guide we'll create plugin that replaces smiles (",(0,i.jsx)(n.code,{children:":)"}),", ",(0,i.jsx)(n.code,{children:":P"}),", etc...) with actual emojis (using ",(0,i.jsx)(n.a,{href:"/docs/concepts/transforms",children:"Node Transforms"}),") and uses own graphics for emojis rendering by creating our own custom node that extends ",(0,i.jsx)(n.a,{href:"/docs/concepts/nodes#textnode",children:"TextNode"}),"."]}),"\n",(0,i.jsx)("figure",{class:"text--center",children:(0,i.jsx)("img",{src:"/img/docs/lexical-emoji-plugin-design.drawio.svg",alt:"Conceptual View"})}),"\n",(0,i.jsx)(n.h2,{id:"preconditions",children:"Preconditions"}),"\n",(0,i.jsxs)(n.p,{children:["We assume that you have already implemented (see ",(0,i.jsx)(n.code,{children:"findEmoji.ts"})," within provided code) function that allows you to find emoji shortcodes (smiles) in text and return their position as well as some other info:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// findEmoji.ts\r\nexport type EmojiMatch = Readonly<{position: number, shortcode: string, unifiedID: string}>;\r\n\r\nexport default function findEmoji(text: string): EmojiMatch | null;\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"creating-own-lexicalnode",children:["Creating own ",(0,i.jsx)(n.code,{children:"LexicalNode"})]}),"\n",(0,i.jsx)(n.p,{children:"Lexical as a framework provides 2 ways to customize appearance of it's content:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["By extending one of the base nodes:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/concepts/nodes#elementnode",children:(0,i.jsx)(n.code,{children:"ElementNode"})})," \u2013 used as parent for other nodes, can be block level or inline."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/concepts/nodes#textnode",children:(0,i.jsx)(n.code,{children:"TextNode"})})," - leaf type (",(0,i.jsx)(n.em,{children:"so it can't have child elements"}),") of node that contains text."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/concepts/nodes#decoratornode",children:(0,i.jsx)(n.code,{children:"DecoratorNode"})})," - useful to insert arbitrary view (component) inside the editor."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Via ",(0,i.jsx)(n.a,{href:"/docs/concepts/node-replacement",children:"Node Overrides"})," \u2013 useful if you want to augment behavior of the built in nodes, such as ",(0,i.jsx)(n.code,{children:"ParagraphNode"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["As in our case we don't expect ",(0,i.jsx)(n.code,{children:"EmojiNode"})," to have any child nodes nor we aim to insert arbitrary component the best choice for us is to proceed with ",(0,i.jsx)(n.a,{href:"/docs/concepts/nodes#textnode",children:(0,i.jsx)(n.code,{children:"TextNode"})})," extension."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export class EmojiNode extends TextNode {\r\n  __unifiedID: string;\r\n\r\n  static getType(): string {\r\n    return 'emoji';\r\n  }\r\n\r\n  static clone(node: EmojiNode): EmojiNode {\r\n    return new EmojiNode(node.__unifiedID, node.__key);\r\n  }\r\n\r\n  constructor(unifiedID: string, key?: NodeKey) {\r\n    const unicodeEmoji = /*...*/;\r\n    super(unicodeEmoji, key);\r\n\r\n    this.__unifiedID = unifiedID.toLowerCase();\r\n  }\r\n\r\n  /**\r\n  * DOM that will be rendered by browser within contenteditable\r\n  * This is what Lexical renders\r\n  */\r\n  createDOM(_config: EditorConfig): HTMLElement {\r\n    const dom = document.createElement('span');\r\n    dom.className = 'emoji-node';\r\n    dom.style.backgroundImage = `url('${BASE_EMOJI_URI}/${this.__unifiedID}.png')`;\r\n    dom.innerText = this.__text;\r\n\r\n    return dom;\r\n  }\r\n\r\n  static importJSON(serializedNode: SerializedEmojiNode): EmojiNode {\r\n    return $createEmojiNode(serializedNode.unifiedID);\r\n  }\r\n\r\n  exportJSON(): SerializedEmojiNode {\r\n    return {\r\n      ...super.exportJSON(),\r\n      type: 'emoji',\r\n      unifiedID: this.__unifiedID,\r\n    };\r\n  }\r\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Example above represents absolute minimal setup of the custom node that extends ",(0,i.jsx)(n.a,{href:"/docs/concepts/nodes#textnode",children:(0,i.jsx)(n.code,{children:"TextNode"})}),". Let's look at the key elements here:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"constructor(...)"})," + class props \u2013 Allows us to store custom data within nodes at runtime as well as accept custom parameters."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getType()"})," & ",(0,i.jsx)(n.code,{children:"clone(...)"})," \u2013 methods allow Lexical to correctly identify node type as well as being able to clone it correctly as we may want to customize cloning behavior."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"importJSON(...)"})," & ",(0,i.jsx)(n.code,{children:"exportJSON()"})," \u2013 define how our data will be serialized / deserialized to/from Lexical state. Here you define your node presentation in state."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"createDOM(...)"})," \u2013 defines DOM that will be rendered by Lexical"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"creating-node-transform",children:"Creating Node Transform"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/docs/concepts/transforms",children:"Transforms"})," allow efficient response to changes to the ",(0,i.jsx)(n.code,{children:"EditorState"}),", and so user input. Their efficiency comes from the fact that transforms are executed before DOM reconciliation (the most expensive operation in Lexical's life cycle)."]}),"\n",(0,i.jsxs)(n.p,{children:["Additionally it's important to mention that ",(0,i.jsx)(n.a,{href:"/docs/concepts/transforms",children:"Lexical Node Transforms"})," are smart enough to allow you not to think about any side effects of the modifications done within transform or interdependencies with other transform listeners. Rule of thumb here is that changes done to the node within a particular transform will trigger rerun of the other transforms till no changes are made to the ",(0,i.jsx)(n.code,{children:"EditorState"}),". Read more about it in ",(0,i.jsx)(n.a,{href:"/docs/concepts/transforms#transform-heuristic",children:"Transform heuristic"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"In our example we have simple transform that executes the following business logic:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Attempt to transform ",(0,i.jsx)(n.code,{children:"TextNode"}),". It will be run on any change to ",(0,i.jsx)(n.code,{children:"TextNode"}),"'s."]}),"\n",(0,i.jsxs)(n.li,{children:["Check if emoji shortcodes (smiles) are present in the text within ",(0,i.jsx)(n.code,{children:"TextNode"}),". Skip if none."]}),"\n",(0,i.jsxs)(n.li,{children:["Split ",(0,i.jsx)(n.code,{children:"TextNode"})," into 2 or 3 pieces (depending on the position of the shortcode in text) so target emoji shortcode has own dedicated ",(0,i.jsx)(n.code,{children:"TextNode"})]}),"\n",(0,i.jsxs)(n.li,{children:["Replace emoji shortcode ",(0,i.jsx)(n.code,{children:"TextNode"})," with ",(0,i.jsx)(n.code,{children:"EmojiNode"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import {LexicalEditor, TextNode} from 'lexical';\r\n\r\n\r\nimport {$createEmojiNode} from './EmojiNode';\r\nimport findEmoji from './findEmoji';\r\n\r\n\r\nfunction textNodeTransform(node: TextNode): void {\r\n  if (!node.isSimpleText() || node.hasFormat('code')) {\r\n    return;\r\n  }\r\n\r\n  const text = node.getTextContent();\r\n\r\n  // Find only 1st occurrence as transform will be re-run anyway for the rest\r\n  // because newly inserted nodes are considered to be dirty\r\n  const emojiMatch = findEmoji(text);\r\n  if (emojiMatch === null) {\r\n    return;\r\n  }\r\n\r\n  let targetNode;\r\n  if (emojiMatch.position === 0) {\r\n    // First text chunk within string, splitting into 2 parts\r\n    [targetNode] = node.splitText(\r\n      emojiMatch.position + emojiMatch.shortcode.length,\r\n    );\r\n  } else {\r\n    // In the middle of a string\r\n    [, targetNode] = node.splitText(\r\n      emojiMatch.position,\r\n      emojiMatch.position + emojiMatch.shortcode.length,\r\n    );\r\n  }\r\n\r\n\r\n  const emojiNode = $createEmojiNode(emojiMatch.unifiedID);\r\n  targetNode.replace(emojiNode);\r\n}\r\n\r\n\r\nexport function registerEmoji(editor: LexicalEditor): () => void {\r\n  // We don't use editor.registerUpdateListener here as alternative approach where we rely\r\n  // on update listener is highly discouraged as it triggers an additional render (the most expensive lifecycle operation).\r\n  return editor.registerNodeTransform(TextNode, textNodeTransform);\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,i.jsxs)(n.p,{children:["Finally we configure Lexical instance with our newly created plugin by registering ",(0,i.jsx)(n.code,{children:"EmojiNode"})," within editor config and executing ",(0,i.jsx)(n.code,{children:"registerEmoji(editor)"})," plugin bootstrap function. Here for that sake of simplicity we assume that the plugin picks its own approach for CSS & Static Assets distribution (if any), Lexical doesn't enforce any rules on that."]}),"\n",(0,i.jsxs)(n.p,{children:["Refer to ",(0,i.jsx)(n.a,{href:"/docs/getting-started/quick-start#putting-it-together",children:"Quick Start (Vanilla JS) Example"})," to fill the gaps in this pseudocode."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import {createEditor} from 'lexical';\r\nimport {mergeRegister} from '@lexical/utils';\r\n/* ... */\r\n\r\nimport {EmojiNode} from './emoji-plugin/EmojiNode';\r\nimport {registerEmoji} from './emoji-plugin/EmojiPlugin';\r\n\r\nconst initialConfig = {\r\n  /* ... */\r\n  // Register our newly created node\r\n  nodes: [EmojiNode, /* ... */],\r\n};\r\n\r\nconst editor = createEditor(config);\r\n\r\nconst editorRef = document.getElementById('lexical-editor');\r\neditor.setRootElement(editorRef);\r\n\r\n// Registering Plugins\r\nmergeRegister(\r\n  /* ... */\r\n  registerEmoji(editor), // Our plugin\r\n);\n"})}),"\n",(0,i.jsx)("iframe",{width:"100%",height:"400",src:"https://stackblitz.com/github/facebook/lexical/tree/main/examples/vanilla-js-plugin?embed=1&file=src%2Femoji-plugin%2FEmojiPlugin.ts&terminalHeight=1&ctl=1",sandbox:"allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts"})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var i=t(14041);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);