"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[3014],{36048:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=i(31085),l=i(71184);const a={custom_edit_url:"https://github.com/facebook/lexical/tree/main/packages/lexical-eslint-plugin/README.md"},t="@lexical/eslint-plugin",s={id:"packages/lexical-eslint-plugin",title:"@lexical/eslint-plugin",description:"This ESLint plugin enforces the Lexical $function convention.",source:"@site/docs/packages/lexical-eslint-plugin.md",sourceDirName:"packages",slug:"/packages/lexical-eslint-plugin",permalink:"/docs/packages/lexical-eslint-plugin",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/lexical/tree/main/packages/lexical-eslint-plugin/README.md",tags:[],version:"current",frontMatter:{custom_edit_url:"https://github.com/facebook/lexical/tree/main/packages/lexical-eslint-plugin/README.md"},sidebar:"docs",previous:{title:"@lexical/dragon",permalink:"/docs/packages/lexical-dragon"},next:{title:"@lexical/file",permalink:"/docs/packages/lexical-file"}},o={},c=[{value:"Installation",id:"installation",level:2},{value:"Custom Configuration",id:"custom-configuration",level:3},{value:"Advanced configuration",id:"advanced-configuration",level:3},{value:"<code>isDollarFunction</code>",id:"isdollarfunction",level:4},{value:"<code>isIgnoredFunction</code>",id:"isignoredfunction",level:4},{value:"<code>isLexicalProvider</code>",id:"islexicalprovider",level:4},{value:"<code>isSafeDollarFunction</code>",id:"issafedollarfunction",level:4},{value:"Valid and Invalid Examples",id:"valid-and-invalid-examples",level:2},{value:"Valid Examples",id:"valid-examples",level:3},{value:"Invalid Examples",id:"invalid-examples",level:3},{value:"Rename autofix",id:"rename-autofix",level:4},{value:"Rename &amp; deprecate autofix",id:"rename--deprecate-autofix",level:4},{value:"Rename scope conflict",id:"rename-scope-conflict",level:4}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"lexicaleslint-plugin",children:(0,r.jsx)(n.code,{children:"@lexical/eslint-plugin"})})}),"\n",(0,r.jsxs)(n.p,{children:["This ESLint plugin enforces the ",(0,r.jsx)(n.a,{href:"https://lexical.dev/docs/intro#reading-and-updating-editor-state",children:"Lexical $function convention"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsx)(n.p,{children:"Assuming you already have ESLint installed, run:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"npm install @lexical/eslint-plugin --save-dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"Then extend the recommended eslint config:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'{\r\n  "extends": [\r\n    // ...\r\n    "plugin:@lexical/recommended"\r\n  ]\r\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"custom-configuration",children:"Custom Configuration"}),"\n",(0,r.jsx)(n.p,{children:"If you want more fine-grained configuration, you can instead add a snippet like this to your ESLint configuration file:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'{\r\n  "plugins": [\r\n    // ...\r\n    "@lexical"\r\n  ],\r\n  "rules": {\r\n    // ...\r\n    "@lexical/rules-of-lexical": "error"\r\n  }\r\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-configuration",children:"Advanced configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Most of the heuristics in ",(0,r.jsx)(n.code,{children:"@lexical/rules-of-lexical"})," can be extended with\r\nadditional terms or patterns."]}),"\n",(0,r.jsx)(n.p,{children:'The code example below is shown using the default implementations for each\r\noption. When you configure these they are combined with the default\r\nimplementations using "OR", the default implementations can not be overridden.\r\nThese terms and patterns are only shown for reference and pasting this example\r\ninto your project is not useful.'}),"\n",(0,r.jsxs)(n.p,{children:["If the string begins with a ",(0,r.jsx)(n.code,{children:'"^"'})," or ",(0,r.jsx)(n.code,{children:'"("'})," then it is treated as a RegExp,\r\notherwise it will be an exact match. A string may also be used instead\r\nof an array of strings."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'{\r\n  "plugins": [\r\n    // ...\r\n    "@lexical"\r\n  ],\r\n  "rules": {\r\n    // ...\r\n    "@lexical/rules-of-lexical": [\r\n      "error",\r\n      {\r\n        "isDollarFunction": ["^\\\\$[a-z_]"],\r\n        "isIgnoredFunction": [],\r\n        "isLexicalProvider": [\r\n          "parseEditorState",\r\n          "read",\r\n          "registerCommand",\r\n          "registerNodeTransform",\r\n          "update"\r\n        ],\r\n        "isSafeDollarFunction": ["^\\\\$is"]\r\n      }\r\n    ]\r\n  }\r\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"isdollarfunction",children:(0,r.jsx)(n.code,{children:"isDollarFunction"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Base case"}),": ",(0,r.jsx)(n.code,{children:"/^\\$[a-z_]/"})]}),"\n",(0,r.jsxs)(n.p,{children:["This defines the $function convention, which by default is any function that\r\nstarts with a dollar sign followed by a lowercase latin letter. You may have a\r\nsecondary convention in your codebase, such as non-latin letters, or an\r\ninternal prefix that you want to consider (e.g. ",(0,r.jsx)(n.code,{children:'"^INTERNAL_\\\\$"'}),")."]}),"\n",(0,r.jsx)(n.h4,{id:"isignoredfunction",children:(0,r.jsx)(n.code,{children:"isIgnoredFunction"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Base case"}),": None"]}),"\n",(0,r.jsx)(n.p,{children:"Functions that match these patterns are ignored from analysis, they may call\r\nLexical $functions but are not considered to be a dollar function themselves."}),"\n",(0,r.jsx)(n.h4,{id:"islexicalprovider",children:(0,r.jsx)(n.code,{children:"isLexicalProvider"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Base case"}),": ",(0,r.jsx)(n.code,{children:"/^(parseEditorState|read|registerCommand|registerNodeTransform|update)$/"})]}),"\n",(0,r.jsx)(n.p,{children:"These are functions that allow their function argument to use Lexical\r\n$functions."}),"\n",(0,r.jsx)(n.h4,{id:"issafedollarfunction",children:(0,r.jsx)(n.code,{children:"isSafeDollarFunction"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Base case"}),": ",(0,r.jsx)(n.code,{children:"/^\\$is/"})]}),"\n",(0,r.jsx)(n.p,{children:"These $functions are considered safe to call from anywhere, generally\r\nthese functions are runtime type checks that do not depend on any other\r\nstate."}),"\n",(0,r.jsx)(n.h2,{id:"valid-and-invalid-examples",children:"Valid and Invalid Examples"}),"\n",(0,r.jsx)(n.h3,{id:"valid-examples",children:"Valid Examples"}),"\n",(0,r.jsx)(n.p,{children:"$functions may be called by other $functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function $namedCorrectly() {\r\n  return $getRoot();\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"$functions may be called in functions defined when calling the following\r\nmethods (the heuristic only considers the method name):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"editor.update"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"editorState.read"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"editor.registerCommand"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"editor.registerNodeTransform"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function validUsesEditorOrState(editor) {\r\n  editor.update(() => $getRoot());\r\n  editor.getLatestState().read(() => $getRoot());\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"$functions may be called from class methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class CustomNode extends ElementNode {\r\n  appendText(string) {\r\n    this.appendChild($createTextNode(string));\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"invalid-examples",children:"Invalid Examples"}),"\n",(0,r.jsx)(n.h4,{id:"rename-autofix",children:"Rename autofix"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function invalidFunction() {\r\n  return $getRoot();\r\n}\r\nfunction $callsInvalidFunction() {\r\n  return invalidFunction();\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Autofix:"})," The function is renamed with a $ prefix. Any references to this\r\nname in this module are also always renamed."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function $invalidFunction() {\r\n  return $getRoot();\r\n}\r\nfunction $callsInvalidFunction() {\r\n  return $invalidFunction();\r\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"rename--deprecate-autofix",children:"Rename & deprecate autofix"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export function exportedInvalidFunction() {\r\n  return $getRoot();\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Autofix:"})," The exported function is renamed with a $ prefix. The previous name\r\nis also exported and marked deprecated, because automatic renaming of\r\nreferences to that name is limited to the module's scope."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export function $exportedInvalidFunction() {\r\n  return $getRoot();\r\n}\r\n/** @deprecated renamed to {@link $exportedInvalidFunction} by @lexical/eslint-plugin rules-of-lexical */\r\nexport const exportedInvalidFunction = $exportedInvalidFunction;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"rename-scope-conflict",children:"Rename scope conflict"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {$getRoot} from 'lexical';\r\nfunction InvalidComponent() {\r\n  const [editor] = useLexicalComposerContext();\r\n  const getRoot = useCallback(() => $getRoot(), []);\r\n  return (<button onClick={() => editor.update(() => getRoot())} />);\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"Autofix:"})," The function is renamed with a $ prefix and _ suffix since the suggested name was already in scope."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {$getRoot} from 'lexical';\r\nfunction InvalidComponent() {\r\n  const [editor] = useLexicalComposerContext();\r\n  const $getRoot_ = useCallback(() => $getRoot(), []);\r\n  return (<button onClick={() => editor.update(() => $getRoot_())} />);\r\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},71184:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>s});var r=i(14041);const l={},a=r.createContext(l);function t(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);