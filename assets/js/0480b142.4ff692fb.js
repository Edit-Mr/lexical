"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[8070],{70974:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var o=t(31085),s=t(71184);const i={sidebar_position:7},r="FAQ",a={id:"faq",title:"FAQ",description:"Why does Lexical use the $ prefix in the name of many of the functions?",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/docs/faq",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/lexical/tree/main/packages/lexical-website/docs/faq.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"docs",previous:{title:"Collaboration FAQ",permalink:"/docs/collaboration/faq"}},d={},c=[{value:"Why does Lexical use the <code>$</code> prefix in the name of many of the functions?",id:"why-does-lexical-use-the--prefix-in-the-name-of-many-of-the-functions",level:2},{value:"When does reconciliation happen?",id:"when-does-reconciliation-happen",level:2},{value:"Why do tests use <code>await editor.update(\u2026)</code>",id:"why-do-tests-use-await-editorupdate",level:2},{value:"How do I listen for user text insertions?",id:"how-do-i-listen-for-user-text-insertions",level:2},{value:"How do I clear the contents of the editor?",id:"how-do-i-clear-the-contents-of-the-editor",level:2},{value:"How do I listen to specific key down events?",id:"how-do-i-listen-to-specific-key-down-events",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"faq",children:"FAQ"})}),"\n",(0,o.jsxs)(n.h2,{id:"why-does-lexical-use-the--prefix-in-the-name-of-many-of-the-functions",children:["Why does Lexical use the ",(0,o.jsx)(n.code,{children:"$"})," prefix in the name of many of the functions?"]}),"\n",(0,o.jsxs)(n.p,{children:["Originally, Lexical didn't have ",(0,o.jsx)(n.code,{children:"$"})," functions, instead these functions were provided to you through callback params:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Mid 2020 API\r\neditor.update((viewState) => {\r\n  const getRoot = viewState.getRoot();\r\n  ..\r\n});\r\neditor.addTextTransform((viewState) => {\r\n  const getRoot = viewState.getRoot();\r\n  ..\r\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"Internally, this approach raised some negative feedback:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"viewState"})," terminology was confusing. It wasn't really a ",(0,o.jsx)(n.code,{children:"viewState"}),", more like a toolkit to manipulate the ",(0,o.jsx)(n.code,{children:"EditorState"})]}),"\n",(0,o.jsx)(n.li,{children:"For complex updates and transforms devs had to carry params around on many layers"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:['This is when we decided to leverage the "lexical" scope instead to perform ',(0,o.jsx)(n.code,{children:"EditorState"})," manipulation, and the ",(0,o.jsx)(n.code,{children:"$"})," represents just that."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"editor.update(() => ...);\r\neditor.registerNodeTransform(FooNode, () => ...);\r\neditor.getEditorState().read(...);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you've used React Hooks before, you can think of ",(0,o.jsx)(n.code,{children:"$"})," functions as being something that follows a similar pattern. These are functions that show their intent as to where they can or cannot be used. This makes it possible for a developer to create their own functions that give the same signal, by simply prefixing the function with the dollar."]}),"\n",(0,o.jsx)(n.p,{children:"Internally, we've found this scales really well and developers get to grips with it in almost no time at all."}),"\n",(0,o.jsx)(n.h2,{id:"when-does-reconciliation-happen",children:"When does reconciliation happen?"}),"\n",(0,o.jsxs)(n.p,{children:["Reconciliation is scheduled with\r\n",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask",children:"queueMicrotask"}),",\r\nwhich means that it will happen very soon, but asynchronously. This is similar\r\nto something like ",(0,o.jsx)(n.code,{children:"setTimeout(reconcile, 0)"})," with a bit more immediacy or\r\n",(0,o.jsx)(n.code,{children:"Promise.resolve().then(reconcile)"})," with less overhead. This is done so\r\nthat all of the updates that occur as a result of a single logical event will\r\nbe batched into one reconciliation."]}),"\n",(0,o.jsxs)(n.p,{children:["You can force a reconciliation to take place synchronously with the discrete\r\noption to ",(0,o.jsx)(n.code,{children:"editor.update"})," (demonstrated below)."]}),"\n",(0,o.jsxs)(n.h2,{id:"why-do-tests-use-await-editorupdate",children:["Why do tests use ",(0,o.jsx)(n.code,{children:"await editor.update(\u2026)"})]}),"\n",(0,o.jsx)(n.p,{children:"You may notice that many tests look like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"await editor.update(updateA);\r\nawait editor.update(updateB);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["An astute observer would notice that this seems very strange, since\r\n",(0,o.jsx)(n.code,{children:"editor.update()"})," returns ",(0,o.jsx)(n.code,{children:"void"})," and not ",(0,o.jsx)(n.code,{children:"Promise<void>"}),". However,\r\nit does happen to work as you would want it to because\r\nthe implementation of Promise uses the same microtask queue."]}),"\n",(0,o.jsxs)(n.p,{children:["It's not recommended to rely on this in browser code as it could depend on\r\nimplementation details of the compilers, bundlers, and VM. It's best to stick\r\nto using the ",(0,o.jsx)(n.code,{children:"discrete"})," or the ",(0,o.jsx)(n.code,{children:"onUpdate"})," callback options to be sure that\r\nthe reconciliation has taken place."]}),"\n",(0,o.jsx)(n.p,{children:"Ignoring any other microtasks that were scheduled elsewhere,\r\nit is roughly equivalent to this synchronous code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"editor.update(updateA, {discrete: true});\r\neditor.update(updateB, {discrete: true});\n"})}),"\n",(0,o.jsx)(n.p,{children:"At a high level, very roughly, the order of operations looks like this:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"editor.update()"})," is called"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"updateA()"})," is called and updates the editor state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"editor.update()"})," schedules a reconciliation microtask and returns"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"await"})," schedules a resume microtask and yields control to the task executor"]}),"\n",(0,o.jsx)(n.li,{children:"the reconciliation microtask runs, reconciling the editor state with the DOM"}),"\n",(0,o.jsx)(n.li,{children:"the resume microtask runs"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"how-do-i-listen-for-user-text-insertions",children:"How do I listen for user text insertions?"}),"\n",(0,o.jsxs)(n.p,{children:["Listening to text insertion events is problematic with content editables in general. It's a common source of bugs due to how\r\ndifferent browsers and third-party extensions interact with the DOM. Whilst it's possible to use DOM events like ",(0,o.jsx)(n.code,{children:"input"})," and\r\n",(0,o.jsx)(n.code,{children:"beforeinput"})," to gauge some of the possible cases where a user has inserted text, these are hardly reliable and also don't\r\ntake into account edge-cases. Instead, Lexical prefers to consider any change as a possible user input, and as such doesn't\r\nmake a distinction between the cases. This is important for tools like spellcheck, browser extensions, IME, speech-to-text,\r\nscreen readers and other external tools that often don't reliably trigger a reliable event sequence (some don't even trigger\r\nany events at all!)."]}),"\n",(0,o.jsx)(n.p,{children:"For those wanting to react to a text change and possibly block/alter the intent, the recommended approach is to use a node\r\ntransform. This also plays nicely with other sub-systems at play that might also be looking to do the same thing as you."}),"\n",(0,o.jsx)(n.p,{children:"For those who just want to know of the changes, this can be achieved using a text content listener or an editor update listener."}),"\n",(0,o.jsx)(n.h2,{id:"how-do-i-clear-the-contents-of-the-editor",children:"How do I clear the contents of the editor?"}),"\n",(0,o.jsxs)(n.p,{children:["You can go this by calling ",(0,o.jsx)(n.code,{children:"clear()"})," on the RootNode in an update callback:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"editor.update(() => {\r\n  $getRoot().clear();\r\n})\n"})}),"\n",(0,o.jsx)(n.h2,{id:"how-do-i-listen-to-specific-key-down-events",children:"How do I listen to specific key down events?"}),"\n",(0,o.jsx)(n.p,{children:"You can leverage Lexical's command listening system. Lexical provides specific commands for many common keyboard operations, such as:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ARROW_LEFT_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ARROW_RIGHT_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ARROW_UP_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ARROW_DOWN_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_SPACE_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ENTER_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_BACKSPACE_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_DELETE_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_TAB_COMMAND"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.code,{children:"KEY_ESCAPE_COMMAND"})}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import {KEY_ENTER_COMMAND, COMMAND_PRIORITY_LOW} from 'lexical';\r\n\r\neditor.registerCommand(KEY_ENTER_COMMAND, (event: KeyboardEvent) => {\r\n  // Handle enter key presses here\r\n  return false;\r\n}, COMMAND_PRIORITY_LOW)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can use the generic ",(0,o.jsx)(n.code,{children:"KEY_DOWN_COMMAND"})," command to listen\r\nto all keydown events. Do note, that returning ",(0,o.jsx)(n.code,{children:"true"})," in your listener will prevent any\r\nother key based commands from firing, so in most cases you'll want to return ",(0,o.jsx)(n.code,{children:"false"})," from\r\nthe command listener."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import {KEY_DOWN_COMMAND, COMMAND_PRIORITY_LOW} from 'lexical';\r\n\r\neditor.registerCommand(KEY_DOWN_COMMAND, (event: KeyboardEvent) => {\r\n  // Handle event here\r\n  return false;\r\n}, COMMAND_PRIORITY_LOW)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(14041);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);