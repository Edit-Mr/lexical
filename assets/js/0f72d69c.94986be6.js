"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[4300],{55261:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(31085),i=n(71184);const a={},o="Editor State",s={id:"concepts/editor-state",title:"Editor State",description:"Why is it necessary?",source:"@site/docs/concepts/editor-state.md",sourceDirName:"concepts",slug:"/concepts/editor-state",permalink:"/docs/concepts/editor-state",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/lexical/tree/main/packages/lexical-website/docs/concepts/editor-state.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Developer Tools",permalink:"/docs/getting-started/devtools"},next:{title:"Nodes",permalink:"/docs/concepts/nodes"}},d={},l=[{value:"Why is it necessary?",id:"why-is-it-necessary",level:2},{value:"Understanding the Editor State",id:"understanding-the-editor-state",level:2},{value:"Updating state",id:"updating-state",level:2},{value:"State update listener",id:"state-update-listener",level:2},{value:"When are Listeners, Transforms, and Commands called?",id:"when-are-listeners-transforms-and-commands-called",level:2},{value:"Synchronous reconciliation with discrete updates",id:"synchronous-reconciliation-with-discrete-updates",level:2},{value:"Cloning state",id:"cloning-state",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"editor-state",children:"Editor State"})}),"\n",(0,r.jsx)(t.h2,{id:"why-is-it-necessary",children:"Why is it necessary?"}),"\n",(0,r.jsx)(t.p,{children:"With Lexical, the source of truth is not the DOM, but rather an underlying state model\r\nthat Lexical maintains and associates with an editor instance."}),"\n",(0,r.jsx)(t.p,{children:'While HTML is great for storing rich text content it\'s often "way too flexible" when it comes to text editing.\r\nFor example the following lines of content will produce equal outcome:'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<i><b>Lexical</b></i>\r\n<i><b>Lex<b><b>ical</b></i>\r\n<b><i>Lexical</i></b>\n"})}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"See rendered version!"}),(0,r.jsxs)("div",{children:[(0,r.jsx)("i",{children:(0,r.jsx)("b",{children:"Lexical"})}),(0,r.jsxs)("i",{children:[(0,r.jsx)("b",{children:"Lex"}),(0,r.jsx)("b",{children:"ical"})]}),(0,r.jsx)("b",{children:(0,r.jsx)("i",{children:"Lexical"})})]})]}),"\n",(0,r.jsx)(t.p,{children:"Of course, there are ways to normalize all these variants to a single canonical form, however this would require DOM manipulation and so re-rendering of the content. And to overcome this we can use Virtual DOM, or State."}),"\n",(0,r.jsx)(t.p,{children:"On top of that it allows to decouple content structure from content formatting. Let's look at this example stored in HTML:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<p>Why did the JavaScript developer go to the bar? <b>Because he couldn't handle his <i>Promise</i>s</b></p>\n"})}),"\n",(0,r.jsxs)("figure",{class:"text--center",children:[(0,r.jsx)("img",{src:"/img/docs/state-formatting-html.drawio.svg",alt:"Nested structure of the HTML state"}),(0,r.jsx)("figcaption",{children:"Nested structure of the HTML state because of the formatting"})]}),"\n",(0,r.jsx)(t.p,{children:"In contrast, Lexical decouples structure from formatting by offsetting this information to attributes. This allows us to have canonical document structure regardless of the order in which different styles were applied."}),"\n",(0,r.jsxs)("figure",{class:"text--center",children:[(0,r.jsx)("img",{src:"/img/docs/state-formatting-lexical.png",alt:"Flat Lexical state"}),(0,r.jsx)("figcaption",{children:"Flat Lexical state structure"})]}),"\n",(0,r.jsx)(t.h2,{id:"understanding-the-editor-state",children:"Understanding the Editor State"}),"\n",(0,r.jsxs)(t.p,{children:["You can get the latest editor state from an editor by calling ",(0,r.jsx)(t.code,{children:"editor.getEditorState()"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Editor states have two phases:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:'During an update they can be thought of as "mutable". See "Updating state" below to\r\nmutate an editor state.'}),"\n",(0,r.jsx)(t.li,{children:'After an update, the editor state is then locked and deemed immutable from there on. This\r\neditor state can therefore be thought of as a "snapshot".'}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Editor states contain two core things:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"The editor node tree (starting from the root node)."}),"\n",(0,r.jsx)(t.li,{children:"The editor selection (which can be null)."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Editor states are serializable to JSON, and the editor instance provides a useful method\r\nto deserialize stringified editor states."}),"\n",(0,r.jsx)(t.p,{children:"Here's an example of how you can initialize editor with some state and then persist it:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'// Get editor initial state (e.g. loaded from backend)\r\nconst loadContent = async () => {\r\n  // \'empty\' editor\r\n  const value = \'{"root":{"children":[{"children":[],"direction":null,"format":"","indent":0,"type":"paragraph","version":1}],"direction":null,"format":"","indent":0,"type":"root","version":1}}\';\r\n\r\n  return value;\r\n}\r\n\r\nconst initialEditorState = await loadContent();\r\nconst editor = createEditor(...);\r\nregisterRichText(editor, initialEditorState);\r\n\r\n...\r\n\r\n// Handler to store content (e.g. when user submits a form)\r\nconst onSubmit = () => {\r\n  await saveContent(JSON.stringify(editor.getEditorState()));\r\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"For React it could be something like the following:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",children:'const initialEditorState = await loadContent();\r\nconst editorStateRef = useRef(undefined);\r\n\r\n<LexicalComposer initialConfig={{\r\n  editorState: initialEditorState\r\n}}>\r\n  <LexicalRichTextPlugin />\r\n  <LexicalOnChangePlugin onChange={(editorState) => {\r\n    editorStateRef.current = editorState;\r\n  }} />\r\n  <Button label="Save" onPress={() => {\r\n    if (editorStateRef.current) {\r\n      saveContent(JSON.stringify(editorStateRef.current))\r\n    }\r\n  }} />\r\n</LexicalComposer>\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Note that Lexical uses ",(0,r.jsx)(t.code,{children:"initialConfig.editorState"})," only once (when it's being initialized) and passing different value later\r\nwon't be reflected in editor. See \"Update state\" below for proper ways of updating editor state."]}),"\n",(0,r.jsx)(t.h2,{id:"updating-state",children:"Updating state"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["For a deep dive into how state updates work, check out ",(0,r.jsx)(t.a,{href:"https://dio.la/article/lexical-state-updates",children:"this blog post"})," by Lexical contributor ",(0,r.jsx)(t.a,{href:"https://twitter.com/daniguardio_la",children:"@DaniGuardiola"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["The most common way to update the editor is to use ",(0,r.jsx)(t.code,{children:"editor.update()"}),'. Calling this function\r\nrequires a function to be passed in that will provide access to mutate the underlying\r\neditor state. When starting a fresh update, the current editor state is cloned and\r\nused as the starting point. From a technical perspective, this means that Lexical leverages a technique\r\ncalled double-buffering during updates. There\'s the "current" frozen editor state to represent what was\r\nmost recently reconciled to the DOM, and another work-in-progress "pending" editor state that represents\r\nfuture changes for the next reconciliation.']}),"\n",(0,r.jsxs)(t.p,{children:["Reconciling an update is typically an async process that allows Lexical to batch multiple synchronous\r\nupdates of the editor state together in a single update to the DOM \u2013 improving performance. When\r\nLexical is ready to commit the update to the DOM, the underlying mutations and changes in the update\r\nbatch will form a new immutable editor state. Calling ",(0,r.jsx)(t.code,{children:"editor.getEditorState()"})," will then return the\r\nlatest editor state based on the changes from the update."]}),"\n",(0,r.jsx)(t.p,{children:"Here's an example of how you can update an editor instance:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import {$getRoot, $getSelection} from 'lexical';\r\nimport {$createParagraphNode} from 'lexical';\r\n\r\n// Inside the `editor.update` you can use special $ prefixed helper functions.\r\n// These functions cannot be used outside the closure, and will error if you try.\r\n// (If you're familiar with React, you can imagine these to be a bit like using a hook\r\n// outside of a React function component).\r\neditor.update(() => {\r\n  // Get the RootNode from the EditorState\r\n  const root = $getRoot();\r\n\r\n  // Get the selection from the EditorState\r\n  const selection = $getSelection();\r\n\r\n  // Create a new ParagraphNode\r\n  const paragraphNode = $createParagraphNode();\r\n\r\n  // Create a new TextNode\r\n  const textNode = $createTextNode('Hello world');\r\n\r\n  // Append the text node to the paragraph\r\n  paragraphNode.append(textNode);\r\n\r\n  // Finally, append the paragraph to the root\r\n  root.append(paragraphNode);\r\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Another way to set state is ",(0,r.jsx)(t.code,{children:"setEditorState"})," method, which replaces current state with the one passed as an argument."]}),"\n",(0,r.jsx)(t.p,{children:"Here's an example of how you can set editor state from a stringified JSON:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const editorState = editor.parseEditorState(editorStateJSONString);\r\neditor.setEditorState(editorState);\n"})}),"\n",(0,r.jsx)(t.h2,{id:"state-update-listener",children:"State update listener"}),"\n",(0,r.jsx)(t.p,{children:"If you want to know when the editor updates so you can react to the changes, you can add an update\r\nlistener to the editor, as shown below:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"editor.registerUpdateListener(({editorState}) => {\r\n  // The latest EditorState can be found as `editorState`.\r\n  // To read the contents of the EditorState, use the following API:\r\n\r\n  editorState.read(() => {\r\n    // Just like editor.update(), .read() expects a closure where you can use\r\n    // the $ prefixed helper functions.\r\n  });\r\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"when-are-listeners-transforms-and-commands-called",children:"When are Listeners, Transforms, and Commands called?"}),"\n",(0,r.jsx)(t.p,{children:"There are several types of callbacks that can be registered with the editor that are related to\r\nupdates of the Editor State."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Callback Type"}),(0,r.jsx)(t.th,{children:"When It's Called"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Update Listener"}),(0,r.jsx)(t.td,{children:"After reconciliation"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Mutation Listener"}),(0,r.jsx)(t.td,{children:"After reconciliation"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Node Transform"}),(0,r.jsxs)(t.td,{children:["During ",(0,r.jsx)(t.code,{children:"editor.update()"}),", after the callback finishes, if any instances of the node type they are registered for were updated"]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Command"}),(0,r.jsxs)(t.td,{children:["As soon as the command is dispatched to the editor (called from an implicit ",(0,r.jsx)(t.code,{children:"editor.update()"}),")"]})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"synchronous-reconciliation-with-discrete-updates",children:"Synchronous reconciliation with discrete updates"}),"\n",(0,r.jsx)(t.p,{children:"While commit scheduling and batching are normally what we want, they can sometimes get in the way."}),"\n",(0,r.jsx)(t.p,{children:"Consider this example: you're trying to manipulate an editor state in a server context and then persist it in a database."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"editor.update(() => {\r\n  // manipulate the state...\r\n});\r\n\r\nsaveToDatabase(editor.getEditorState().toJSON());\n"})}),"\n",(0,r.jsxs)(t.p,{children:["This code will not work as expected, because the ",(0,r.jsx)(t.code,{children:"saveToDatabase"})," call will happen before the state has been committed.\r\nThe state that will be saved will be the same one that existed before the update."]}),"\n",(0,r.jsxs)(t.p,{children:["Fortunately, the ",(0,r.jsx)(t.code,{children:"discrete"})," option for ",(0,r.jsx)(t.code,{children:"LexicalEditor.update"})," forces an update to be immediately committed."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"editor.update(() => {\r\n  // manipulate the state...\r\n}, {discrete: true});\r\n\r\nsaveToDatabase(editor.getEditorState().toJSON());\n"})}),"\n",(0,r.jsx)(t.h3,{id:"cloning-state",children:"Cloning state"}),"\n",(0,r.jsx)(t.p,{children:"Lexical state can be cloned, optionally with custom selection. One of the scenarios where you'd want to do it\r\nis setting editor's state but not forcing any selection:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"// Passing `null` as a selection value to prevent focusing the editor\r\neditor.setEditorState(editorState.clone(null));\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},71184:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var r=n(14041);const i={},a=r.createContext(i);function o(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);