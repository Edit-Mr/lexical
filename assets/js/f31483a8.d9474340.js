"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[4349],{97896:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var r=t(31085),o=t(71184);const i={sidebar_position:2},s="Collaboration FAQ",a={id:"collaboration/faq",title:"Collaboration FAQ",description:"Source of truth: Lexical State, Yjs and App's DB",source:"@site/docs/collaboration/faq.md",sourceDirName:"collaboration",slug:"/collaboration/faq",permalink:"/docs/collaboration/faq",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/lexical/tree/main/packages/lexical-website/docs/collaboration/faq.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docs",previous:{title:"React",permalink:"/docs/collaboration/react"},next:{title:"FAQ",permalink:"/docs/faq"}},c={},d=[{value:"Source of truth: Lexical State, Yjs and App&#39;s DB",id:"source-of-truth-lexical-state-yjs-and-apps-db",level:2},{value:"Initializing <code>EditorState</code> from Yjs Document",id:"initializing-editorstate-from-yjs-document",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"collaboration-faq",children:"Collaboration FAQ"})}),"\n",(0,r.jsx)(n.h2,{id:"source-of-truth-lexical-state-yjs-and-apps-db",children:"Source of truth: Lexical State, Yjs and App's DB"}),"\n",(0,r.jsx)(n.p,{children:"It's recommended to treat the Yjs model as the source of truth. You can store the document to a database for indexing.\r\nBut, if possible, you should never forget the Yjs model, as this is the only way clients without internet access can reliably join and sync with the server."}),"\n",(0,r.jsx)(n.p,{children:"You can also treat the database as the source of truth. This is how it could be achieved:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Clients receive a ",(0,r.jsx)(n.code,{children:"sessionId"})," when they connect to the server"]}),"\n",(0,r.jsxs)(n.li,{children:["When a client connects without an existing ",(0,r.jsx)(n.code,{children:"sessionId"}),", get the content from the database and create a ",(0,r.jsx)(n.code,{children:"sessionId"})]}),"\n",(0,r.jsxs)(n.li,{children:["When all clients disconnect, forget the room content and ",(0,r.jsx)(n.code,{children:"sessionId"})," on the server after some timeout (e.g. 1 hour)"]}),"\n",(0,r.jsxs)(n.li,{children:["When a client reconnects, use that content on the server. Furthermore, get the ",(0,r.jsx)(n.code,{children:"sessionId"})," from the client"]}),"\n",(0,r.jsxs)(n.li,{children:["When two clients with different ",(0,r.jsx)(n.code,{children:"sessionId"})," reconnect, one of the clients should forget the room content. ",(0,r.jsx)(n.em,{children:"In this case the client will lose content"})," - although it is very unlikely if you set the forget timeout (see point 2) very high."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Or, there is an ever simpler approach:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"When a client connects to the server, the server populates the room content if empty"}),"\n",(0,r.jsx)(n.li,{children:"When all clients disconnect, the server forgets the room content after some timeout (e.g. 1 hour)"}),"\n",(0,r.jsx)(n.li,{children:"When a client was not able to reconnect for 40 minutes, the client must forget its local updates and start fresh (this should be enforced by the server)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"When the database is the source of truth, and if you want to be able to forget the Yjs model, you will always run into cases where clients are not able to commit changes. That's not too bad in most projects. It somehow limits you, because you can't cache the document on the client using y-indexeddb. On the other hand, it is much easier to maintain, and do Yjs upgrades. Furthermore, most people would say that SQL is a bit more reliable than Yjs."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["* Based on the advice of the Yjs author - ",(0,r.jsx)(n.a,{href:"https://github.com/yjs/yjs/issues/82#issuecomment-328365015",children:"Kevin Jahns"})]})}),"\n",(0,r.jsxs)(n.h2,{id:"initializing-editorstate-from-yjs-document",children:["Initializing ",(0,r.jsx)(n.code,{children:"EditorState"})," from Yjs Document"]}),"\n",(0,r.jsx)(n.p,{children:"It's achievable by leveraging headless Lexical and no-op provider for Yjs:"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"createHeadlessCollaborativeEditor.ts"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import type {Binding, Provider} from '@lexical/yjs';\r\nimport type {\r\n  Klass,\r\n  LexicalEditor,\r\n  LexicalNode,\r\n  LexicalNodeReplacement,\r\n  SerializedEditorState,\r\n  SerializedLexicalNode,\r\n} from 'lexical';\r\n\r\nimport {createHeadlessEditor} from '@lexical/headless';\r\nimport {\r\n  createBinding,\r\n  syncLexicalUpdateToYjs,\r\n  syncYjsChangesToLexical,\r\n} from '@lexical/yjs';\r\nimport {type YEvent, applyUpdate, Doc, Transaction} from 'yjs';\r\n\r\nexport default function headlessConvertYDocStateToLexicalJSON(\r\n  nodes: ReadonlyArray<Klass<LexicalNode> | LexicalNodeReplacement>,\r\n  yDocState: Uint8Array,\r\n): SerializedEditorState<SerializedLexicalNode> {\r\n  return withHeadlessCollaborationEditor(nodes, (editor, binding) => {\r\n    applyUpdate(binding.doc, yDocState, {isUpdateRemote: true});\r\n    editor.update(() => {}, {discrete: true});\r\n\r\n    return editor.getEditorState().toJSON();\r\n  });\r\n}\r\n\r\n/**\r\n * Creates headless collaboration editor with no-op provider (since it won't\r\n * connect to message distribution infra) and binding. It also sets up\r\n * bi-directional synchronization between yDoc and editor\r\n */\r\nfunction withHeadlessCollaborationEditor<T>(\r\n  nodes: ReadonlyArray<Klass<LexicalNode> | LexicalNodeReplacement>,\r\n  callback: (editor: LexicalEditor, binding: Binding, provider: Provider) => T,\r\n): T {\r\n  const editor = createHeadlessEditor({\r\n    nodes,\r\n  });\r\n\r\n  const id = 'main';\r\n  const doc = new Doc();\r\n  const docMap = new Map([[id, doc]]);\r\n  const provider = createNoOpProvider();\r\n  const binding = createBinding(editor, provider, id, doc, docMap);\r\n\r\n  const unsubscribe = registerCollaborationListeners(editor, provider, binding);\r\n\r\n  const res = callback(editor, binding, provider);\r\n\r\n  unsubscribe();\r\n\r\n  return res;\r\n}\r\n\r\nfunction registerCollaborationListeners(\r\n  editor: LexicalEditor,\r\n  provider: Provider,\r\n  binding: Binding,\r\n): () => void {\r\n  const unsubscribeUpdateListener = editor.registerUpdateListener(\r\n    ({\r\n      dirtyElements,\r\n      dirtyLeaves,\r\n      editorState,\r\n      normalizedNodes,\r\n      prevEditorState,\r\n      tags,\r\n    }) => {\r\n      if (tags.has('skip-collab') === false) {\r\n        syncLexicalUpdateToYjs(\r\n          binding,\r\n          provider,\r\n          prevEditorState,\r\n          editorState,\r\n          dirtyElements,\r\n          dirtyLeaves,\r\n          normalizedNodes,\r\n          tags,\r\n        );\r\n      }\r\n    },\r\n  );\r\n\r\n  const observer = (events: Array<YEvent<any>>, transaction: Transaction) => {\r\n    if (transaction.origin !== binding) {\r\n      syncYjsChangesToLexical(binding, provider, events, false);\r\n    }\r\n  };\r\n\r\n  binding.root.getSharedType().observeDeep(observer);\r\n\r\n  return () => {\r\n    unsubscribeUpdateListener();\r\n    binding.root.getSharedType().unobserveDeep(observer);\r\n  };\r\n}\r\n\r\nfunction createNoOpProvider(): Provider {\r\n  const emptyFunction = () => {};\r\n\r\n  return {\r\n    awareness: {\r\n      getLocalState: () => null,\r\n      getStates: () => new Map(),\r\n      off: emptyFunction,\r\n      on: emptyFunction,\r\n      setLocalState: emptyFunction,\r\n    },\r\n    connect: emptyFunction,\r\n    disconnect: emptyFunction,\r\n    off: emptyFunction,\r\n    on: emptyFunction,\r\n  };\r\n}\n"})})]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(14041);const o={},i=r.createContext(o);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);