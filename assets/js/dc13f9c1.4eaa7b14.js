"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[8751],{84194:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var o=t(31085),r=t(71184);const s={},i="React FAQ",c={id:"react/faq",title:"React FAQ",description:"My app does not work in dev when using StrictMode, help!?",source:"@site/docs/react/faq.md",sourceDirName:"react",slug:"/react/faq",permalink:"/docs/react/faq",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/lexical/tree/main/packages/lexical-website/docs/react/faq.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Creating a React Plugin",permalink:"/docs/react/create_plugin"},next:{title:"React",permalink:"/docs/collaboration/react"}},a={},l=[{value:"My app does not work in dev when using StrictMode, help!?",id:"my-app-does-not-work-in-dev-when-using-strictmode-help",level:2},{value:"LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext",id:"lexicalcomposercontextuselexicalcomposercontext-cannot-find-a-lexicalcomposercontext",level:2},{value:"Other complications when using dev mode with fast refresh (aka hot module replacement)",id:"other-complications-when-using-dev-mode-with-fast-refresh-aka-hot-module-replacement",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"react-faq",children:"React FAQ"})}),"\n",(0,o.jsx)(n.h2,{id:"my-app-does-not-work-in-dev-when-using-strictmode-help",children:"My app does not work in dev when using StrictMode, help!?"}),"\n",(0,o.jsxs)(n.p,{children:["When hooks are used correctly, there are no known issues with React StrictMode\r\nand Lexical. The first thing you should do is go through React's documentation\r\nto make sure that your usage of ",(0,o.jsx)(n.code,{children:"useEffect"})," and other hooks follow React's\r\nconventions and guidelines. This is a great place to start:\r\n",(0,o.jsx)(n.a,{href:"https://react.dev/reference/react/useEffect#my-effect-runs-twice-when-the-component-mounts",children:"My Effect runs twice when the component mounts"})]}),"\n",(0,o.jsx)(n.p,{children:"Some Lexical-specific concerns (which are consequences of React's\r\nconcurrent and StrictMode semantics, not due to anything unusual in Lexical):"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["In React 19, ",(0,o.jsx)(n.code,{children:"useMemo"})," calls are cached across StrictMode re-renders, so\r\nonly one editor will be used for both renders. If you have a ",(0,o.jsx)(n.code,{children:"useEffect"}),"\r\ncall with side-effects (such as updating the document when a plug-in\r\ninitializes), then you should first check to make sure that this effect\r\nhas not already occurred (e.g. by checking the state of the document or\r\nundoing the change as a cleanup function returned by the effect)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"LexicalComposer"}),"'s initialConfig prop is only considered once during\r\nthe first render (",(0,o.jsx)(n.code,{children:"useMemo"})," is used to create the ",(0,o.jsx)(n.code,{children:"LexicalComposerContext"}),"\r\nwhich includes the editor and theme)"]}),"\n",(0,o.jsxs)(n.li,{children:["If you are using an ",(0,o.jsx)(n.code,{children:"editorState"})," argument in the config when creating the\r\neditor, it will only be called once when the editor is created."]}),"\n",(0,o.jsxs)(n.li,{children:["You should generally prefer to use hooks that return state such as\r\n",(0,o.jsx)(n.code,{children:"useLexicalEditable"})," (",(0,o.jsx)(n.code,{children:"useLexicalSubscription"})," is a generalization of this\r\nstyle) rather than manually registering the listeners and expecting a\r\nparticular sequence of triggers to be called, especially\r\nwhen their source is an effect. Listeners are only called when state\r\nchanges, and in StrictMode the state may have changed during the initial\r\nrender. The listeners registered from your second render will not be called\r\nif the change was triggered by the first render, and you will likely not\r\nsee the listeners triggered during the first render because those effects\r\nwere immediately cleaned up before the change effect occurred."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"lexicalcomposercontextuselexicalcomposercontext-cannot-find-a-lexicalcomposercontext",children:"LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext"}),"\n",(0,o.jsxs)(n.p,{children:["This error happens for one reason: the ",(0,o.jsx)(n.code,{children:"useLexicalComposerContext()"})," hook\r\nwas called from a component that is not a child of a ",(0,o.jsx)(n.code,{children:"LexicalComposer"}),",\r\n",(0,o.jsx)(n.code,{children:"LexicalNestedComposer"}),", or ",(0,o.jsx)(n.code,{children:"LexicalComposerContext.Provider"})," from the same\r\nbuild of Lexical that the hook was imported from."]}),"\n",(0,o.jsx)(n.p,{children:"The most common root causes of this issue are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["You are trying to use ",(0,o.jsx)(n.code,{children:"useLexicalComposerContext()"})," in a component that is\r\nnot a child of the ",(0,o.jsx)(n.code,{children:"LexicalComposer"}),". If you need to do that, you need to\r\npass the context or editor up the tree with something like ",(0,o.jsx)(n.code,{children:"EditorRefPlugin"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["You have multiple builds of Lexical in your project. This could be because\r\nyou have a dependency that has a direct dependency on some other version\r\nof Lexical (these packages should have Lexical as ",(0,o.jsx)(n.code,{children:"peerDependencies"}),", but\r\nnot all do), or because your project mixes import and require statements\r\nto import Lexical (including both the esm and cjs builds of the same\r\nversion of Lexical). Resolving this generally requires overriding what\r\nyour package manager does in ",(0,o.jsx)(n.code,{children:"package.json"}),", and/or what the bundler does in\r\nsome configuration file for your framework or bundler. There are a lot of\r\ncombinations of tools in the ecosystem (npm, pnpm, yarn, webpack, vite,\r\nnext.js, etc.), so the syntax of that workaround is quite dependent on\r\nprecisely which tools (and even versions of those tools) that your project\r\nis using."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"other-complications-when-using-dev-mode-with-fast-refresh-aka-hot-module-replacement",children:"Other complications when using dev mode with fast refresh (aka hot module replacement)"}),"\n",(0,o.jsxs)(n.p,{children:["Depending on precisely how the fast refresh implementation you're\r\nusing works, you may need to mark the files that create your editor or the\r\nimplementation of your LexicalNode subclasses as needing a full refresh.\r\nWhen things seem broken in dev mode after changing a file, try refreshing the\r\npage first. If that fixes the problem, then mark the file you're working on as\r\nneeding a full refresh. For example\r\n",(0,o.jsx)(n.a,{href:"https://nextjs.org/docs/architecture/fast-refresh#tips",children:"Next.js fast refresh"}),"\r\nhas a ",(0,o.jsx)(n.code,{children:"// @refresh reset"})," comment that can be used."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var o=t(14041);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);