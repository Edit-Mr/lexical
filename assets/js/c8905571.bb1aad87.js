"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[4731],{35227:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>a});var r=o(31085),t=o(71184);const d={},s="Nodes",i={id:"concepts/nodes",title:"Nodes",description:"Base Nodes",source:"@site/docs/concepts/nodes.md",sourceDirName:"concepts",slug:"/concepts/nodes",permalink:"/docs/concepts/nodes",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/lexical/tree/main/packages/lexical-website/docs/concepts/nodes.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Editor State",permalink:"/docs/concepts/editor-state"},next:{title:"Node Overrides",permalink:"/docs/concepts/node-replacement"}},c={},a=[{value:"Base Nodes",id:"base-nodes",level:2},{value:"<code>RootNode</code>",id:"rootnode",level:3},{value:"<code>LineBreakNode</code>",id:"linebreaknode",level:3},{value:"<code>ElementNode</code>",id:"elementnode",level:3},{value:"<code>TextNode</code>",id:"textnode",level:3},{value:"<code>DecoratorNode</code>",id:"decoratornode",level:3},{value:"Node Properties",id:"node-properties",level:2},{value:"Creating custom nodes",id:"creating-custom-nodes",level:2},{value:"Extending <code>ElementNode</code>",id:"extending-elementnode",level:3},{value:"Extending <code>TextNode</code>",id:"extending-textnode",level:3},{value:"Extending <code>DecoratorNode</code>",id:"extending-decoratornode",level:3}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"nodes",children:"Nodes"})}),"\n",(0,r.jsx)(n.h2,{id:"base-nodes",children:"Base Nodes"}),"\n",(0,r.jsxs)(n.p,{children:["Nodes are a core concept in Lexical. Not only do they form the visual editor view, as part of the ",(0,r.jsx)(n.code,{children:"EditorState"}),", but they also represent the\r\nunderlying data model for what is stored in the editor at any given time. Lexical has a single core based node, called ",(0,r.jsx)(n.code,{children:"LexicalNode"})," that\r\nis extended internally to create Lexical's five base nodes:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"RootNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"LineBreakNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ElementNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"TextNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"DecoratorNode"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Of these nodes, three of them are exposed from the ",(0,r.jsx)(n.code,{children:"lexical"})," package, making them ideal to be extended:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"ElementNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"TextNode"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"DecoratorNode"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rootnode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalRootNode.ts",children:(0,r.jsx)(n.code,{children:"RootNode"})})}),"\n",(0,r.jsxs)(n.p,{children:["There is only ever a single ",(0,r.jsx)(n.code,{children:"RootNode"})," in an ",(0,r.jsx)(n.code,{children:"EditorState"})," and it is always at the top and it represents the\r\n",(0,r.jsx)(n.code,{children:"contenteditable"})," itself. This means that the ",(0,r.jsx)(n.code,{children:"RootNode"})," does not have a parent or siblings."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["To get the text content of the entire editor, you should use ",(0,r.jsx)(n.code,{children:"rootNode.getTextContent()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["To avoid selection issues, Lexical forbids insertion of text nodes directly into a ",(0,r.jsx)(n.code,{children:"RootNode"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"linebreaknode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalLineBreakNode.ts",children:(0,r.jsx)(n.code,{children:"LineBreakNode"})})}),"\n",(0,r.jsxs)(n.p,{children:["You should never have ",(0,r.jsx)(n.code,{children:"'\\n'"})," in your text nodes, instead you should use the ",(0,r.jsx)(n.code,{children:"LineBreakNode"})," which represents\r\n",(0,r.jsx)(n.code,{children:"'\\n'"}),", and more importantly, can work consistently between browsers and operating systems."]}),"\n",(0,r.jsx)(n.h3,{id:"elementnode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalElementNode.ts",children:(0,r.jsx)(n.code,{children:"ElementNode"})})}),"\n",(0,r.jsxs)(n.p,{children:["Used as parent for other nodes, can be block level (",(0,r.jsx)(n.code,{children:"ParagraphNode"}),", ",(0,r.jsx)(n.code,{children:"HeadingNode"}),") and inline (",(0,r.jsx)(n.code,{children:"LinkNode"}),").\r\nHas various methods which define its behaviour that can be overridden during extension (",(0,r.jsx)(n.code,{children:"isInline"}),", ",(0,r.jsx)(n.code,{children:"canBeEmpty"}),", ",(0,r.jsx)(n.code,{children:"canInsertTextBefore"})," and more)"]}),"\n",(0,r.jsx)(n.h3,{id:"textnode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalTextNode.ts",children:(0,r.jsx)(n.code,{children:"TextNode"})})}),"\n",(0,r.jsx)(n.p,{children:"Leaf type of node that contains text. It also includes few text-specific properties:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"format"})," any combination of ",(0,r.jsx)(n.code,{children:"bold"}),", ",(0,r.jsx)(n.code,{children:"italic"}),", ",(0,r.jsx)(n.code,{children:"underline"}),", ",(0,r.jsx)(n.code,{children:"strikethrough"}),", ",(0,r.jsx)(n.code,{children:"code"}),", ",(0,r.jsx)(n.code,{children:"subscript"})," and ",(0,r.jsx)(n.code,{children:"superscript"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"mode"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"token"})," - acts as immutable node, can't change its content and is deleted all at once"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"segmented"})," - its content deleted by segments (one word at a time), it is editable although node becomes non-segmented once its content is updated"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"style"})," can be used to apply inline css styles to text"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"decoratornode",children:(0,r.jsx)(n.a,{href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalDecoratorNode.ts",children:(0,r.jsx)(n.code,{children:"DecoratorNode"})})}),"\n",(0,r.jsx)(n.p,{children:"Wrapper node to insert arbitrary view (component) inside the editor. Decorator node rendering is framework-agnostic and\r\ncan output components from React, vanilla js or other frameworks."}),"\n",(0,r.jsx)(n.h2,{id:"node-properties",children:"Node Properties"}),"\n",(0,r.jsxs)(n.p,{children:["Lexical nodes can have properties. It's important that these properties are JSON serializable too, so you should never\r\nbe assigning a property to a node that is a function, Symbol, Map, Set, or any other object that has a different prototype\r\nthan the built-ins. ",(0,r.jsx)(n.code,{children:"null"}),", ",(0,r.jsx)(n.code,{children:"undefined"}),", ",(0,r.jsx)(n.code,{children:"number"}),", ",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"boolean"}),", ",(0,r.jsx)(n.code,{children:"{}"})," and ",(0,r.jsx)(n.code,{children:"[]"})," are all types of property that can be\r\nassigned to node."]}),"\n",(0,r.jsxs)(n.p,{children:["By convention, we prefix properties with ",(0,r.jsx)(n.code,{children:"__"})," (double underscore) so that it makes it clear that these properties are private\r\nand their access should be avoided directly. We opted for ",(0,r.jsx)(n.code,{children:"__"})," instead of ",(0,r.jsx)(n.code,{children:"_"})," because of the fact that some build tooling\r\nmangles and minifies single ",(0,r.jsx)(n.code,{children:"_"})," prefixed properties to improve code size. However, this breaks down if you're exposing a node\r\nto be extended outside of your build."]}),"\n",(0,r.jsxs)(n.p,{children:["If you are adding a property that you expect to be modifiable or accessible, then you should always create a set of ",(0,r.jsx)(n.code,{children:"get*()"}),"\r\nand ",(0,r.jsx)(n.code,{children:"set*()"})," methods on your node for this property. Inside these methods, you'll need to invoke some very important methods\r\nthat ensure consistency with Lexical's internal immutable system. These methods are ",(0,r.jsx)(n.code,{children:"getWritable()"})," and ",(0,r.jsx)(n.code,{children:"getLatest()"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import type {NodeKey} from 'lexical';\r\n\r\nclass MyCustomNode extends SomeOtherNode {\r\n  __foo: string;\r\n\r\n  constructor(foo: string, key?: NodeKey) {\r\n    super(key);\r\n    this.__foo = foo;\r\n  }\r\n\r\n  setFoo(foo: string) {\r\n    // getWritable() creates a clone of the node\r\n    // if needed, to ensure we don't try and mutate\r\n    // a stale version of this node.\r\n    const self = this.getWritable();\r\n    self.__foo = foo;\r\n  }\r\n\r\n  getFoo(): string {\r\n    // getLatest() ensures we are getting the most\r\n    // up-to-date value from the EditorState.\r\n    const self = this.getLatest();\r\n    return self.__foo;\r\n  }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Lastly, all nodes should have both a ",(0,r.jsx)(n.code,{children:"static getType()"})," method and a ",(0,r.jsx)(n.code,{children:"static clone()"})," method.\r\nLexical uses the type to be able to reconstruct a node back with its associated class prototype\r\nduring deserialization (important for copy + paste!). Lexical uses cloning to ensure consistency\r\nbetween creation of new ",(0,r.jsx)(n.code,{children:"EditorState"})," snapshots."]}),"\n",(0,r.jsx)(n.p,{children:"Expanding on the example above with these methods:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class MyCustomNode extends SomeOtherNode {\r\n  __foo: string;\r\n\r\n  static getType(): string {\r\n    return 'custom-node';\r\n  }\r\n\r\n  static clone(node: MyCustomNode): MyCustomNode {\r\n    // If any state needs to be set after construction, it should be\r\n    // done by overriding the `afterCloneFrom` instance method.\r\n    return new MyCustomNode(node.__foo, node.__key);\r\n  }\r\n\r\n  constructor(foo: string, key?: NodeKey) {\r\n    super(key);\r\n    this.__foo = foo;\r\n  }\r\n\r\n  setFoo(foo: string) {\r\n    // getWritable() creates a clone of the node\r\n    // if needed, to ensure we don't try and mutate\r\n    // a stale version of this node.\r\n    const self = this.getWritable();\r\n    self.__foo = foo;\r\n  }\r\n\r\n  getFoo(): string {\r\n    // getLatest() ensures we are getting the most\r\n    // up-to-date value from the EditorState.\r\n    const self = this.getLatest();\r\n    return self.__foo;\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"creating-custom-nodes",children:"Creating custom nodes"}),"\n",(0,r.jsx)(n.p,{children:"As mentioned above, Lexical exposes three base nodes that can be extended."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Did you know? Nodes such as ",(0,r.jsx)(n.code,{children:"ElementNode"})," are already extended in the core by Lexical, such as ",(0,r.jsx)(n.code,{children:"ParagraphNode"})," and ",(0,r.jsx)(n.code,{children:"RootNode"}),"!"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"extending-elementnode",children:["Extending ",(0,r.jsx)(n.code,{children:"ElementNode"})]}),"\n",(0,r.jsxs)(n.p,{children:["Below is an example of how you might extend ",(0,r.jsx)(n.code,{children:"ElementNode"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {ElementNode, LexicalNode} from 'lexical';\r\n\r\nexport class CustomParagraph extends ElementNode {\r\n  static getType(): string {\r\n    return 'custom-paragraph';\r\n  }\r\n\r\n  static clone(node: CustomParagraph): CustomParagraph {\r\n    return new CustomParagraph(node.__key);\r\n  }\r\n\r\n  createDOM(): HTMLElement {\r\n    // Define the DOM element here\r\n    const dom = document.createElement('p');\r\n    return dom;\r\n  }\r\n\r\n  updateDOM(prevNode: CustomParagraph, dom: HTMLElement): boolean {\r\n    // Returning false tells Lexical that this node does not need its\r\n    // DOM element replacing with a new copy from createDOM.\r\n    return false;\r\n  }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It's also good etiquette to provide some ",(0,r.jsx)(n.code,{children:"$"})," prefixed utility functions for\r\nyour custom ",(0,r.jsx)(n.code,{children:"ElementNode"})," so that others can easily consume and validate nodes\r\nare that of your custom node. Here's how you might do this for the above example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export function $createCustomParagraphNode(): CustomParagraph {\r\n  return new CustomParagraph();\r\n}\r\n\r\nexport function $isCustomParagraphNode(node: LexicalNode | null | undefined): node is CustomParagraph  {\r\n  return node instanceof CustomParagraph;\r\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"extending-textnode",children:["Extending ",(0,r.jsx)(n.code,{children:"TextNode"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export class ColoredNode extends TextNode {\r\n  __color: string;\r\n\r\n  constructor(text: string, color: string, key?: NodeKey): void {\r\n    super(text, key);\r\n    this.__color = color;\r\n  }\r\n\r\n  static getType(): string {\r\n    return 'colored';\r\n  }\r\n\r\n  static clone(node: ColoredNode): ColoredNode {\r\n    return new ColoredNode(node.__text, node.__color, node.__key);\r\n  }\r\n\r\n  createDOM(config: EditorConfig): HTMLElement {\r\n    const element = super.createDOM(config);\r\n    element.style.color = this.__color;\r\n    return element;\r\n  }\r\n\r\n  updateDOM(\r\n    prevNode: ColoredNode,\r\n    dom: HTMLElement,\r\n    config: EditorConfig,\r\n  ): boolean {\r\n    const isUpdated = super.updateDOM(prevNode, dom, config);\r\n    if (prevNode.__color !== this.__color) {\r\n      dom.style.color = this.__color;\r\n    }\r\n    return isUpdated;\r\n  }\r\n}\r\n\r\nexport function $createColoredNode(text: string, color: string): ColoredNode {\r\n  return new ColoredNode(text, color);\r\n}\r\n\r\nexport function $isColoredNode(node: LexicalNode | null | undefined): node is ColoredNode {\r\n  return node instanceof ColoredNode;\r\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"extending-decoratornode",children:["Extending ",(0,r.jsx)(n.code,{children:"DecoratorNode"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export class VideoNode extends DecoratorNode<ReactNode> {\r\n  __id: string;\r\n\r\n  static getType(): string {\r\n    return 'video';\r\n  }\r\n\r\n  static clone(node: VideoNode): VideoNode {\r\n    return new VideoNode(node.__id, node.__key);\r\n  }\r\n\r\n  constructor(id: string, key?: NodeKey) {\r\n    super(key);\r\n    this.__id = id;\r\n  }\r\n\r\n  createDOM(): HTMLElement {\r\n    return document.createElement('div');\r\n  }\r\n\r\n  updateDOM(): false {\r\n    return false;\r\n  }\r\n\r\n  decorate(): ReactNode {\r\n    return <VideoPlayer videoID={this.__id} />;\r\n  }\r\n}\r\n\r\nexport function $createVideoNode(id: string): VideoNode {\r\n  return new VideoNode(id);\r\n}\r\n\r\nexport function $isVideoNode(\r\n  node: LexicalNode | null | undefined,\r\n): node is VideoNode {\r\n  return node instanceof VideoNode;\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"useDecorators"}),", ",(0,r.jsx)(n.code,{children:"PlainTextPlugin"})," and ",(0,r.jsx)(n.code,{children:"RichTextPlugin"})," executes ",(0,r.jsx)(n.code,{children:"React.createPortal(reactDecorator, element)"})," for each ",(0,r.jsx)(n.code,{children:"DecoratorNode"}),",\r\nwhere the ",(0,r.jsx)(n.code,{children:"reactDecorator"})," is what is returned by ",(0,r.jsx)(n.code,{children:"DecoratorNode.prototype.decorate"}),",\r\nand the ",(0,r.jsx)(n.code,{children:"element"})," is an ",(0,r.jsx)(n.code,{children:"HTMLElement"})," returned by ",(0,r.jsx)(n.code,{children:"DecoratorNode.prototype.createDOM"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},71184:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>i});var r=o(14041);const t={},d=r.createContext(t);function s(e){const n=r.useContext(d);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(d.Provider,{value:n},e.children)}}}]);