"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[807],{30674:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(31085),i=n(71184);const o={sidebar_position:2},a="Getting Started with React",s={id:"getting-started/react",title:"Getting Started with React",description:"Video Tutorials",source:"@site/docs/getting-started/react.md",sourceDirName:"getting-started",slug:"/getting-started/react",permalink:"/docs/getting-started/react",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/lexical/tree/main/packages/lexical-website/docs/getting-started/react.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docs",previous:{title:"Quick Start (Vanilla JS)",permalink:"/docs/getting-started/quick-start"},next:{title:"Theming",permalink:"/docs/getting-started/theming"}},l={},c=[{value:"Video Tutorials",id:"video-tutorials",level:2},{value:"Creating Basic Rich Text Editor",id:"creating-basic-rich-text-editor",level:2},{value:"Adding UI to control text formatting",id:"adding-ui-to-control-text-formatting",level:2},{value:"Saving Lexical State",id:"saving-lexical-state",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"getting-started-with-react",children:"Getting Started with React"})}),"\n",(0,r.jsx)(t.h2,{id:"video-tutorials",children:"Video Tutorials"}),"\n",(0,r.jsx)(t.p,{children:"For a detailed walkthrough of setting up a basic editor with Lexical in React, check out these videos:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=qIqxvk2qcmo",children:"Getting Started with Lexical & React"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=pIBUFYd9zJY",children:"Themes, Nodes, and Rich Text"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=5sRh_WXw0WI",children:"Headings, Lists, Toolbar"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://www.youtube.com/watch?v=abZNazybzvs",children:"Creating Nodes and Plugins"})}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Keep in mind that some of these videos may be partially outdated as we do not update them as often as textual documentation."}),"\n",(0,r.jsx)(t.h2,{id:"creating-basic-rich-text-editor",children:"Creating Basic Rich Text Editor"}),"\n",(0,r.jsxs)(t.p,{children:["To simplify Lexical integration with React we provide the ",(0,r.jsx)(t.code,{children:"@lexical/react"})," package that wraps Lexical APIs with React components so the editor itself as well as all the plugins now can be easily composed using JSX.\r\nFurthermore, you can lazy load plugins if desired, so you don't pay the cost for plugins until you actually use them."]}),"\n",(0,r.jsxs)(t.p,{children:["To start, install ",(0,r.jsx)(t.code,{children:"lexical"})," and ",(0,r.jsx)(t.code,{children:"@lexical/react"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"npm install --save lexical @lexical/react\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Below is an example of a basic rich text editor using ",(0,r.jsx)(t.code,{children:"lexical"})," and ",(0,r.jsx)(t.code,{children:"@lexical/react"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",children:"import {$getRoot, $getSelection} from 'lexical';\r\nimport {useEffect} from 'react';\r\n\r\nimport {AutoFocusPlugin} from '@lexical/react/LexicalAutoFocusPlugin';\r\nimport {LexicalComposer} from '@lexical/react/LexicalComposer';\r\nimport {RichTextPlugin} from '@lexical/react/LexicalRichTextPlugin';\r\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\r\nimport {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\r\nimport {LexicalErrorBoundary} from '@lexical/react/LexicalErrorBoundary';\r\n\r\nconst theme = {\r\n  // Theme styling goes here\r\n  //...\r\n}\r\n\r\n// Catch any errors that occur during Lexical updates and log them\r\n// or throw them as needed. If you don't throw them, Lexical will\r\n// try to recover gracefully without losing user data.\r\nfunction onError(error) {\r\n  console.error(error);\r\n}\r\n\r\nfunction Editor() {\r\n  const initialConfig = {\r\n    namespace: 'MyEditor',\r\n    theme,\r\n    onError,\r\n  };\r\n\r\n  return (\r\n    <LexicalComposer initialConfig={initialConfig}>\r\n      <RichTextPlugin\r\n        contentEditable={<ContentEditable />}\r\n        placeholder={<div>Enter some text...</div>}\r\n        ErrorBoundary={LexicalErrorBoundary}\r\n      />\r\n      <HistoryPlugin />\r\n      <AutoFocusPlugin />\r\n    </LexicalComposer>\r\n  );\r\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"adding-ui-to-control-text-formatting",children:"Adding UI to control text formatting"}),"\n",(0,r.jsx)(t.p,{children:"Out of the box Lexical doesn't provide any type of UI as it's not a ready to use editor but rather a framework for creation of your own editor.\r\nBelow you can find an example of the integration from the previous chapter that now features 2 new plugins:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"ToolbarPlugin"})," - renders UI to control text formatting"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"TreeViewPlugin"})," - renders debug view below the editor so we can see its state in real time"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["However no UI can be created w/o CSS and Lexical is not an exception here. Pay attention to ",(0,r.jsx)(t.code,{children:"ExampleTheme.ts"})," and how it's used in this example, with corresponding styles defined in ",(0,r.jsx)(t.code,{children:"styles.css"}),"."]}),"\n",(0,r.jsx)("iframe",{width:"100%",height:"400",src:"https://stackblitz.com/github/facebook/lexical/tree/main/examples/react-rich?embed=1&file=src%2FApp.tsx&terminalHeight=0&ctl=1",sandbox:"allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts"}),"\n",(0,r.jsx)(t.h2,{id:"saving-lexical-state",children:"Saving Lexical State"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["While we attempt to write our own plugin here for demonstration purposes, in real life projects it's better to opt for ",(0,r.jsx)(t.a,{href:"/docs/react/plugins#lexicalonchangeplugin",children:"LexicalOnChangePlugin"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["Now that we have a simple editor in React, the next thing we might want to do is access the content of the editor to, for instance,\r\nsave it in a database. We can do this via the an ",(0,r.jsx)(t.a,{href:"https://lexical.dev/docs/concepts/listeners#registerupdatelistener",children:"update listener"}),", which will execute every time the editor state changes and provide us with the latest state. In React, we typically use the plugin system to set up listeners like this, since it provides us easy access to the LexicalEditor instance via a React Context. So, let's write our own plugin that notifies us when the editor updates."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",children:"// When the editor changes, you can get notified via the\r\n// OnChangePlugin!\r\nfunction MyOnChangePlugin({ onChange }) {\r\n  // Access the editor through the LexicalComposerContext\r\n  const [editor] = useLexicalComposerContext();\r\n  // Wrap our listener in useEffect to handle the teardown and avoid stale references.\r\n  useEffect(() => {\r\n    // most listeners return a teardown function that can be called to clean them up.\r\n    return editor.registerUpdateListener(({editorState}) => {\r\n      // call onChange here to pass the latest state up to the parent.\r\n      onChange(editorState);\r\n    });\r\n  }, [editor, onChange]);\r\n  return null;\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Now, we can implement this in our editor and save the EditorState in a React state variable:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",children:"function MyOnChangePlugin({ onChange }) {\r\n  const [editor] = useLexicalComposerContext();\r\n  useEffect(() => {\r\n    return editor.registerUpdateListener(({editorState}) => {\r\n      onChange(editorState);\r\n    });\r\n  }, [editor, onChange]);\r\n  return null;\r\n}\r\n\r\nfunction Editor() {\r\n  // ...\r\n\r\n  const [editorState, setEditorState] = useState();\r\n  function onChange(editorState) {\r\n    setEditorState(editorState);\r\n  }\r\n\r\n  return (\r\n    <LexicalComposer initialConfig={initialConfig}>\r\n      <RichTextPlugin\r\n        contentEditable={<ContentEditable />}\r\n        placeholder={<div>Enter some text...</div>}\r\n        ErrorBoundary={LexicalErrorBoundary}\r\n      />\r\n      <HistoryPlugin />\r\n      <MyCustomAutoFocusPlugin />\r\n      <MyOnChangePlugin onChange={onChange}/>\r\n    </LexicalComposer>\r\n  );\r\n}\r\n\n"})}),"\n",(0,r.jsx)(t.p,{children:"Ok, so now we're saving the EditorState object in a React state variable, but we can't save a JavaScript object to our database - so how do we persist the state so we can load it later? We need to serialize it to a storage format. For this purpose (among others) Lexical provides several serialization APIs that convert EditorState to a string that can be sent over the network and saved to a database. Building on our previous example, we can do that this way:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",children:"function MyOnChangePlugin({ onChange }) {\r\n  const [editor] = useLexicalComposerContext();\r\n  useEffect(() => {\r\n    return editor.registerUpdateListener(({editorState}) => {\r\n      onChange(editorState);\r\n    });\r\n  }, [editor, onChange]);\r\n  return null;\r\n}\r\n\r\nfunction Editor() {\r\n  // ...\r\n\r\n  const [editorState, setEditorState] = useState();\r\n  function onChange(editorState) {\r\n    // Call toJSON on the EditorState object, which produces a serialization safe string\r\n    const editorStateJSON = editorState.toJSON();\r\n    // However, we still have a JavaScript object, so we need to convert it to an actual string with JSON.stringify\r\n    setEditorState(JSON.stringify(editorStateJSON));\r\n  }\r\n\r\n  return (\r\n    <LexicalComposer initialConfig={initialConfig}>\r\n      {/*...*/}\r\n      <MyOnChangePlugin onChange={onChange}/>\r\n    </LexicalComposer>\r\n  );\r\n\n"})}),"\n",(0,r.jsx)(t.p,{children:"From there, it's straightforward to wire up a submit button or some other UI trigger that will take the state from the React state variable and send it to a server for storage in a database."}),"\n",(0,r.jsx)(t.p,{children:"One important thing to note: Lexical is generally meant to be uncontrolled, so avoid trying to pass the EditorState back into Editor.setEditorState or something along those lines."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},71184:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var r=n(14041);const i={},o=r.createContext(i);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);